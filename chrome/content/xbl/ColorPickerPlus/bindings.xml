<?xml version="1.0"?>
<bindings
  xmlns="http://www.mozilla.org/xbl"
  xmlns:xbl="http://www.mozilla.org/xbl"
     xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
>


<!--A picker that can have selected or dragged
    values, and can notify observers of changes to
    these values.
    
    A dragged value is a transient value set while
    the user drags over the picker. A selected value
    is the final value selected by the user, usually
    by releasing the mouse button-->
<binding id="observablePicker">
    <implementation>
        <constructor><![CDATA[
            this.dragObservers = [];
            this.selectObservers = [];
            
            //Register any original observers set before
            //this constructor ran
            if(this.originalDragObservers){
                this.dragObservers = this.originalDragObservers;
            }
            if(this.originalSelectObservers){
                this.selectObservers = this.originalSelectObservers;
            }
        ]]>
        </constructor>
        
        <!--Add an observer that will be notified when
            final selections are made on this picker
            The observer must implement the method
            updatePickerSelect(picker)-->
        <method name="addSelectObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.selectObservers.push(observer);
            ]]>
            </body>
        </method>
        
        <!--Add an observer that will be notified of
            transient values while this picker is being
            dragged.
            The observer must implement the method
            updatePickerDrag(picker)-->
        <method name="addDragObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.dragObservers.push(observer);
            ]]>
            </body>
        </method>
        
        <method name="removeSelectObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.selectObservers.remove(observer);
            ]]>
            </body>
        </method>
        
        <method name="removeDragObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.dragObservers.remove(observer);
            ]]>
            </body>
        </method>
        
        <!--Notify all select observers of a change
            to this picker's selected value-->
        <method name="notifySelectObservers">
            <body><![CDATA[
                for(var i = 0; i < this.selectObservers.length; i++){
                    this.selectObservers[i].updatePickerSelect(this);
                }
            ]]>
            </body>
        </method>
        
        <!--Notify all drag observers of a change to
            the value being dragged over-->
        <method name="notifyDragObservers">
            <parameter name="observer" />
            <body><![CDATA[
                for(var i = 0; i < this.dragObservers.length; i++){
                    this.dragObservers[i].updatePickerDrag(this);
                }
            ]]>
            </body>
        </method>
    </implementation>
</binding>

<binding id="integerPicker"
    extends="#observablePicker">
    <resources>
        <stylesheet src="integerPicker.css"/>
    </resources>

    <content>
        <xul:hbox
            anonid="numberInput">
            <xul:label
                xbl:inherits="value=label"
                control="valueTextbox"/>
            <xul:spacer flex="1"/>
            <xul:textbox
                id="valueTextbox"
                anonid="valueTextbox"
                type="number"
                xbl:inherits="min,max,wraparound"/>
        </xul:hbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.valueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "valueTextbox"
            );
        ]]>
        </constructor>
        
        <property name="value">
            <getter><![CDATA[
                return this.internalValue;
                ]]>
            </getter>
            <setter><![CDATA[
                this.setInternalValue(val);
                return this.internalValue;
                ]]>
            </setter>
        </property>
        
        <!-- "max" is the maximum integer allowed for this element. The
             propety construction here keeps the "max" propery matched
             to the "max" attribute of the bound tag.-->
        <property name="max">
            <getter><![CDATA[
                return this.getAttribute("max");
                ]]>
            </getter>
            <setter><![CDATA[
                return this.setAttribute("max", val);
                ]]>
            </setter>
        </property>
        
        <!-- "min" is the minimum integer allowed for this element. The
             propety construction here keeps the "min" propery matched
             to the "min" attribute of the bound tag.-->
        <property name="min">
            <getter><![CDATA[
                return this.getAttribute("min");
                ]]>
            </getter>
            <setter><![CDATA[
                return this.setAttribute("min", val);
                ]]>
            </setter>
        </property>

        
        <!--Get the current value represented
            by the position of the slide-->
        <method name="setInternalValue">
            <body><![CDATA[
                return this.value;
            ]]></body>
        </method>
        
        
        <!--Set the position of the slide to the
            specified value. Value must be numeric.
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setValue">
            <parameter name="value" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                this.value =
                    Math.min(
                        this.maxValue,
                        Math.max(
                            this.minValue,
                            value
                        )
                    );
                    
                this.slideY =
                    ((this.value - this.topBound) / this.range)
                    * this.activeRegion.boxObject.height;
                this.slide.setAttribute(
                    "style",
                    "top: "+(this.slideY-3)+"px; left: -7px;"
                );
            ]]></body>
        </method>
        
        <!--Increment the value if possible. Wrap around if
            wrapping is enabled.-->
        <method name="increment">
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                var newValue = this.value + 1;
                
                //Clip or wrap if this passes the maxValue
                if (newValue > this.maxValue){
                    if (this.wraps){
                        newValue = this.minValue;
                    }
                    else{
                        newValue = this.maxValue;
                    }
                }
                this.setValue(newValue);
                this.notifyDragObservers();
            ]]></body>
        </method>
        
        <!--Decrement the value if possible. Wrap around if
            wrapping is enabled.-->
        <method name="decrement">
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                var newValue = this.value - 1;
                
                //Clip or wrap if this passes the maxValue
                if (newValue < this.minValue){
                    if (this.wraps){
                        newValue = this.maxValue;
                    }
                    else{
                        newValue = this.minValue;
                    }
                }
                this.setValue(newValue);
                this.notifyDragObservers();
            ]]></body>
        </method>
        


        
        <!--finish any keyboard editing, setting a modified
            value if applicable.-->
        <method name="finishKeyboardEditing">
            <body><![CDATA[
                if(this.keyboardEditStartValue){
                    if(this.keyboardEditStartValue != this.value){
                        this.selectValue();
                    }
                    this.keyboardEditStartValue == null;
                }
            ]]>
            </body>
        </method>
        
    </implementation>

    <handlers>
        <handler event="blur"><![CDATA[
            //Select a final value if we did a keyboard
            //drag action
            this.finishKeyboardEditing();
        ]]>
        </handler>
    </handlers>
</binding>

<binding id="verticalPicker"
    extends="#observablePicker">
    <resources>
        <stylesheet src="verticalPicker.css"/>
    </resources>

    <content>
        <xul:vbox
            flex="1"
            anonid="container"
            pack="center"
            align="center">
            <xul:box
                anonid="holder">
                <xul:box
                anonid="activeRegion">
                    <xul:box
                        id="slide"
                        anonid="slide"
                        style="TOP: -3px; LEFT: -7px;">
                    </xul:box>
                </xul:box>
            </xul:box>
        </xul:vbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.activeRegion = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "activeRegion"
            );
            
            this.slide = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "slide"
            );
            
            this.bottomBound =
                (this.originalBottomBoundaryValue)?
                 this.originalBottomBoundaryValue :
                 0;
            
            this.topBound =
                (this.originalTopBoundaryValue)?
                 this.originalTopBoundaryValue :
                 100;
            
            this.slideY = 0;
            
            this.updateRange();
        ]]>
        </constructor>
        
        <field name="wraps">true</field>
        
        <!--Set the numeric value represented when the
            slide is all the way to the top-->
        <method name="setTopBoundaryValue">
            <parameter name="topBoundaryValue"/>
            <body><![CDATA[
                this.topBound = topBoundaryValue;
                this.updateRange();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            slide is all the way to the bottom-->
        <method name="setBottomBoundaryValue">
            <parameter name="bottomBoundaryValue"/>
            <body><![CDATA[
                this.bottomBound = bottomBoundaryValue;
                this.updateRange();
            ]]></body>
        </method>
        
        <!--Set the minValue and maxValue to reflect
            the current state of bottomBound and topBound.
            The max and min values are used in order to save
            comparisons throughout the rest of the code.-->
        <method name="updateRange">
            <body><![CDATA[
                this.maxValue =
                    Math.max(this.topBound, this.bottomBound);
                this.minValue =
                    Math.min(this.topBound, this.bottomBound);
                    
                this.range = this.bottomBound - this.topBound;
            ]]>
            </body>
        </method>
        
        <!--Get the current value represented
            by the position of the slide-->
        <method name="getValue">
            <body><![CDATA[
                return this.value;
            ]]></body>
        </method>
        
        
        <!--Set the position of the slide to the
            specified value. Value must be numeric.
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setValue">
            <parameter name="value" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                this.value =
                    Math.min(
                        this.maxValue,
                        Math.max(
                            this.minValue,
                            value
                        )
                    );
                    
                this.slideY =
                    ((this.value - this.topBound) / this.range)
                    * this.activeRegion.boxObject.height;
                this.slide.setAttribute(
                    "style",
                    "top: "+(this.slideY-3)+"px; left: -7px;"
                );
            ]]></body>
        </method>
        
        <!--Increment the value if possible. Wrap around if
            wrapping is enabled.-->
        <method name="increment">
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                var newValue = this.value + 1;
                
                //Clip or wrap if this passes the maxValue
                if (newValue > this.maxValue){
                    if (this.wraps){
                        newValue = this.minValue;
                    }
                    else{
                        newValue = this.maxValue;
                    }
                }
                this.setValue(newValue);
                this.notifyDragObservers();
            ]]></body>
        </method>
        
        <!--Decrement the value if possible. Wrap around if
            wrapping is enabled.-->
        <method name="decrement">
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                var newValue = this.value - 1;
                
                //Clip or wrap if this passes the maxValue
                if (newValue < this.minValue){
                    if (this.wraps){
                        newValue = this.maxValue;
                    }
                    else{
                        newValue = this.minValue;
                    }
                }
                this.setValue(newValue);
                this.notifyDragObservers();
            ]]></body>
        </method>
        
        <!--Private use
            Update the value based on the current pixel
            position of the slide-->
        <method name="dragValue">
            <body><![CDATA[
                
                /**
                 * Translate screen coordinates into
                 * logical coordinates
                 */
                
                this.value =
                    ((this.slideY / this.activeRegion.boxObject.height)
                      * this.range
                    )
                    + this.topBound;
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <!--Private use
            Select a final value
            based on the current pixel position of the
            slide. This is for whan an actual selection
            is made - not for transient values while
            dragging around.-->
        <method name="selectValue">
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
        
        <!--finish any keyboard editing, setting a modified
            value if applicable.-->
        <method name="finishKeyboardEditing">
            <body><![CDATA[
                if(this.keyboardEditStartValue){
                    if(this.keyboardEditStartValue != this.value){
                        this.selectValue();
                    }
                    this.keyboardEditStartValue == null;
                }
            ]]>
            </body>
        </method>
        
    </implementation>

    <handlers>
        <handler event="mousedown" button="0" modifiers="none"><![CDATA[
            this.finishKeyboardEditing();
            
            var element = this;
            function drag(event) {
                var newY = event.pageY - element.activeRegion.boxObject.y;
                newY = Math.max(0, Math.min(newY, element.activeRegion.boxObject.height));
                
                element.slideY = newY;
                
                newY -=3;
                
                element.slide.setAttribute(
                    "style",
                    "top: "+newY+"px; left: -7px;"
                );
                
                element.dragValue();
            }
            
            element.activeRegion.addClass("noCursor");
            
            var originalDocumentOnmousemove = document.onmousemove;
            var originalDocumentOnmouseup = document.onmouseup;
            
            document.onmousemove=drag;
            document.onmouseup=function(){
                element.selectValue();
                element.activeRegion.removeClass("noCursor");
                document.onmousemove=originalDocumentOnmousemove;
                document.onmouseup=originalDocumentOnmouseup;
            };
            drag(event);
            
            event.stopPropagation();
        ]]>
        </handler>
        <handler event="keypress"><![CDATA[
            //If this is the beginning of a keyboard edit
            //action, save the initial value.
            if (!this.keyboardEditStartValue &&
                    event.keyCode >= 37 &&
                    event.keyCode <= 40) {
                this.keyboardEditStartValue = this.value;
            }
            
            switch(event.keyCode){
                case 38:
                case 39:
                    this.increment();
                    break;
                case 37:
                case 40:
                    this.decrement();
                    break;
            }
        ]]>
        </handler>
        <handler event="blur"><![CDATA[
            //Select a final value if we did a keyboard
            //drag action
            this.finishKeyboardEditing();
        ]]>
        </handler>
    </handlers>
</binding>


<binding id="huePicker"
    extends="#verticalPicker">
    <resources>
        <stylesheet src="hue.css"/>
    </resources>
    
    <implementation>
        <constructor><![CDATA[
            this.setTopBoundaryValue(360);
            this.setBottomBoundaryValue(0);
        ]]></constructor>
        
        <!--Get the current Hue-->
        <method name="getHue">
            <body><![CDATA[
                return this.value % 360;
            ]]></body>
        </method>
        
        <!--Set the current Hue-->
        <method name="setHue">
            <parameter name="hue" />
            <body><![CDATA[
                this.setValue(hue);
            ]]></body>
        </method>
    </implementation>
</binding>

<binding id="twoDimensionalPicker"
    extends="#observablePicker">
    <resources>
        <stylesheet src="twoDimensionalPicker.css"/>
    </resources>

    <content>
        <xul:vbox
            flex="1"
            anonid="container"
            pack="center"
            align="center">
            <xul:box
                anonid="holder">
            <xul:box
                anonid="activeRegion">
                <xul:box
                    id="picker"
                    anonid="picker"
                    style="TOP: -4px; LEFT: -4px;">
                </xul:box>
            </xul:box></xul:box>
        </xul:vbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            
            this.activeRegion = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "activeRegion"
            );
            
            this.picker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "picker"
            );
            
            this.pickerX = 0;
            this.pickerY = 0;
            
            this.leftBound =
                (this.originalLeftBoundaryValue)?
                 this.originalLeftBoundaryValue :
                 0;
            
            this.rightBound =
                (this.originalRightBoundaryValue)?
                 this.originalRightBoundaryValue :
                 100;
            
            this.bottomBound =
                (this.originalBottomBoundaryValue)?
                 this.originalBottomBoundaryValue :
                 0;
            
            this.topBound =
                (this.originalTopBoundaryValue)?
                 this.originalTopBoundaryValue :
                 100;
            
            this.updateRanges();
        ]]>
        </constructor>
        
        <!--Set the numeric value represented when the
            picker is all the way to the left-->
        <method name="setLeftBoundaryValue">
            <parameter name="leftBoundaryValue"/>
            <body><![CDATA[
                this.leftBound = leftBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            picker is all the way to the right-->
        <method name="setRightBoundaryValue">
            <parameter name="rightBoundaryValue"/>
            <body><![CDATA[
                this.rightBound = rightBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method> 
        
        <!--Set the numeric value represented when the
            picker is all the way to the top-->
        <method name="setTopBoundaryValue">
            <parameter name="topBoundaryValue"/>
            <body><![CDATA[
                this.topBound = topBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            picker is all the way to the bottom-->
        <method name="setBottomBoundaryValue">
            <parameter name="bottomBoundaryValue"/>
            <body><![CDATA[
                this.bottomBound = bottomBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the horizontalMinValue, horizontalMaxValue,
            verticalMinValue and verticalMaxValue to reflect
            the current state of leftBound, rightBound,
            bottomBound, topBound.
            The max and min values are used in order to save
            comparisons throughout the rest of the code.-->
        <method name="updateRanges">
            <body><![CDATA[
                this.horizontalMaxValue =
                    Math.max(this.leftBound, this.rightBound);
                this.horizontalMinValue =
                    Math.min(this.leftBound, this.rightBound);
                this.verticalMaxValue =
                    Math.max(this.topBound, this.bottomBound);
                this.verticalMinValue =
                    Math.min(this.topBound, this.bottomBound);
                    
                this.verticalRange = this.bottomBound - this.topBound;
                this.horizontalRange = this.rightBound - this.leftBound;
            ]]>
            </body>
        </method>
        
        <!--Get the current horizontal value represented
            by the position of the picker-->
        <method name="getHorizontalValue">
            <body><![CDATA[
                return this.horizontalValue;
            ]]></body>
        </method>
        
        <!--Get the current vertical value represented
            by the position of the picker-->
        <method name="getVerticalValue">
            <body><![CDATA[
                return this.verticalValue;
            ]]></body>
        </method>
        
        
        <!--Set the position of the picker to the
            specified value. Value must be numeric
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setHorizontalValue">
            <parameter name="horizontalValue" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting x
                this.horizontalValue =
                    Math.min(
                        this.horizontalMaxValue,
                        Math.max(
                            this.horizontalMinValue,
                            horizontalValue
                        )
                    );
                this.pickerX =
                    ((this.horizontalValue - this.leftBound) / this.horizontalRange)
                    * this.activeRegion.boxObject.width;  
                this.picker.setAttribute(
                    "style",
                    "top: "+(this.pickerY-4)+"px; left: "+(this.pickerX-4)+"px;"
                );
            ]]></body>
        </method>
        
        <!--Set the position of the picker to the
            specified value. Value must be numeric.
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setVerticalValue">
            <parameter name="verticalValue" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                this.verticalValue =
                    Math.min(
                        this.verticalMaxValue,
                        Math.max(
                            this.verticalMinValue,
                            verticalValue
                        )
                    );
                this.pickerY =
                    ((this.verticalValue - this.topBound) / this.verticalRange)
                    * this.activeRegion.boxObject.height;
                this.picker.setAttribute(
                    "style",
                    "top: "+(this.pickerY-4)+"px; left: "+(this.pickerX-4)+"px;"
                );
            ]]></body>
        </method>
        
        <!--Private use
            Update the vertical and horizontal values
            based on the current XY pixel position of
            the picker-->
        <method name="dragValues">
            <body><![CDATA[
                
                /**
                 * Translate screen coordinates into
                 * logical coordinates
                 */
                
                this.horizontalValue =
                    ((this.pickerX / this.activeRegion.boxObject.width)
                      * this.horizontalRange
                    )
                    + this.leftBound;
                
                this.verticalValue =
                    ((this.pickerY / this.activeRegion.boxObject.height)
                      * this.verticalRange
                    )
                    + this.topBound;
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <!--Private use
            Register a final change to the the vertical and
            horizontal values based on the current XY pixel
            position of the picker. This is for whan an
            actual selection is made - not for transient
            values while dragging around.-->
        <method name="selectValues">
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
            
        
        
    </implementation>

    <handlers>
        <handler event="mousedown" button="0" modifiers="none"><![CDATA[
            var element = this;
            function drag(event) {
                var newX = event.pageX - element.activeRegion.boxObject.x;
                var newY = event.pageY - element.activeRegion.boxObject.y;
                newY = Math.max(0, Math.min(newY, element.activeRegion.boxObject.height));
                newX = Math.max(0, Math.min(newX, element.activeRegion.boxObject.width));
                
                element.pickerX = newX;
                element.pickerY = newY;
                
                newX -=4;
                newY -=4;
                
                element.picker.setAttribute(
                    "style",
                    "top: "+newY+"px; left: " + newX + "px;"
                );
                
                element.dragValues();
            }
            
            element.activeRegion.addClass("noCursor");
            
            var originalDocumentOnmousemove = document.onmousemove;
            var originalDocumentOnmouseup = document.onmouseup;
            
            document.onmousemove=drag;
            document.onmouseup=function(){
                element.selectValues();
                element.activeRegion.removeClass("noCursor");
                document.onmousemove=originalDocumentOnmousemove;
                document.onmouseup=originalDocumentOnmouseup;
            };
            drag(event);
            
            event.stopPropagation();
        ]]>
        </handler>
    </handlers>
</binding>

<binding id="saturationValuePicker"
    extends="#twoDimensionalPicker">
    <resources>
        <stylesheet src="saturationValue.css"/>
    </resources>

    <implementation>
        <constructor><![CDATA[
            this.setLeftBoundaryValue(0);
            this.setRightBoundaryValue(1);
            this.setTopBoundaryValue(1);
            this.setBottomBoundaryValue(0);
        ]]></constructor>
        
        <!--Get the current Saturation-->
        <method name="getSaturation">
            <body><![CDATA[
                return this.horizontalValue;
            ]]></body>
        </method>
        
        <!--Get the current Value-->
        <method name="getValue">
            <body><![CDATA[
                return this.verticalValue;
            ]]></body>
        </method>
        
        <!--Set the current Saturation-->
        <method name="setSaturation">
            <parameter name="saturation" />
            <body><![CDATA[
                this.setHorizontalValue(saturation);
            ]]></body>
        </method>
        
        <!--Set the current Value-->
        <method name="setValue">
            <parameter name="value" />
            <body><![CDATA[
                this.setVerticalValue(value);
            ]]></body>
        </method>
        
        <!--Set the background hue of this picker-->
        <method name="setHue">
            <parameter name="hue" />
            <body><![CDATA[
                /**
                 * This sets the hue of the background
                 * element for this color picker. It
                 * does not do full HSB to RGB conversion,
                 * since the saturation and value will
                 * always be full.
                 *
                 * This algorithm works by breaking the
                 * spectrum into six sectors.
                 * Sectors 1 and 2 are the G sectors.
                 * Sectors 3 and 4 are the B sectors.
                 * Sectors 5 and 6 are teh R sectors.
                 *
                 * When the hue is in a particular sector,
                 * that sector's channel is at full strength.
                 * Depending on the sector, a secondary
                 * channel will be at partial strength.
                 * The secondary channel is the "bChannel"
                 * here.
                 */
            
                var bChannel, sector;
                var hex = "rgb(";
                
                //Break the hue into six sectors
                hue /= 60;
                sector = Math.floor(hue);
                
                //Calculate a secondary channel strength
                //based on how far into the sector the
                //particular hue is found
                bChannel = hue - sector;
                if (sector % 2 != 0){
                    bChannel = 1 - bChannel;
                }
                
                //convert to 0-255 scale
                bChannel = Math.round(bChannel * 255);
                
                var rgb = [];
                switch (sector) {
                    case 6:
                    case 0: rgb = [255, bChannel, 0];
                        break;
                    case 1: rgb = [bChannel, 255, 0];
                        break;
                    case 2: rgb = [0, 255, bChannel];
                        break;
                    case 3: rgb = [0, bChannel, 255];
                        break;
                    case 4: rgb = [bChannel, 0, 255];
                        break;
                    case 5: rgb = [255, 0, bChannel];
                        break;
                }
                
                //Make the final CSS "rgb(0,0,0)" string
                hex += rgb.join(",") + ")";
                
                //Set the background color
                this.activeRegion.setAttribute(
                    "style",
                    "background-color: " + hex
                );
            ]]>
            </body>
        </method>
    </implementation>

    <handlers>
    </handlers>
</binding>

<binding id="colorPickerPlus"
    extends="#observablePicker">
    <resources>
        <stylesheet src="colorPickerPlus.css"/>
    </resources>
    
    <content>
        <xul:hbox
            anonid="container">
            <xul:saturationValuePicker
                anonid="saturationValuePicker"/>
            <xul:huePicker
                anonid="huePicker"/>
            <xul:spacer anonid="beforeText" flex="1" />
            <xul:vbox
                anonid="textInputs">
                <xul:vbox
                    anonid="rgbInputs">
                    <xul:hbox
                        anonid="redInput">
                        <xul:label
                            value="R" control="redTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="redTextbox"
                            anonid="redTextbox"
                            class="colorTextInput"
                            type="number" min="0" max="255"/>
                    </xul:hbox>
                    <xul:hbox
                        anonid="greenInput">
                        <xul:label
                            value="G" control="greenTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="greenTextbox"
                            anonid="greenTextbox"
                            class="colorTextInput"
                            type="number" min="0" max="255"/>
                    </xul:hbox>
                    <xul:hbox
                        anonid="blueInput">
                        <xul:label
                            value="B" control="blueTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="blueTextbox"
                            anonid="blueTextbox"
                            class="colorTextInput"
                            type="number" min="0" max="255"/>
                    </xul:hbox>
                </xul:vbox>
                <xul:spacer flex="1" />
                <xul:vbox
                    anonid="hsvInputs">
                    <xul:hbox
                        anonid="hueInput">
                        <xul:label
                            value="H" control="hueTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="hueTextbox"
                            anonid="hueTextbox"
                            class="colorTextInput"
                            wraparound="true"
                            type="number" min="0" max="360"/>
                    </xul:hbox>
                    <xul:hbox
                        anonid="saturationInput">
                        <xul:label
                            value="S" control="saturationTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="saturationTextbox"
                            anonid="saturationTextbox"
                            class="colorTextInput"
                            type="number" min="0" max="100"/>
                    </xul:hbox>
                    <xul:hbox
                        anonid="valueInput">
                        <xul:label
                            value="V" control="valueTextbox"/>
                        <xul:spacer flex="1"/>
                        <xul:textbox
                            id="valueTextbox"
                            anonid="valueTextbox"
                            class="colorTextInput"
                            type="number" min="0" max="100"/>
                    </xul:hbox>
                </xul:vbox>
            </xul:vbox>
        </xul:hbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.saturationValuePicker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "saturationValuePicker"
            );
            
            this.huePicker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "huePicker"
            );
            
            
            this.redTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "redTextbox"
            );
            this.greenTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "greenTextbox"
            );
            this.blueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "blueTextbox"
            );
            
            this.hueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "hueTextbox"
            );
            this.saturationTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "saturationTextbox"
            );
            this.valueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "valueTextbox"
            );
            
            var colorPickerPlus = this;
            
            this.redTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    this.value,
                    colorPickerPlus.rgb[1],
                    colorPickerPlus.rgb[2]);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.greenTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    colorPickerPlus.rgb[0],
                    this.value,
                    colorPickerPlus.rgb[2]);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.blueTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    colorPickerPlus.rgb[0],
                    colorPickerPlus.rgb[1],
                    this.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.hueTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    this.value,
                    colorPickerPlus.saturation,
                    colorPickerPlus.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.saturationTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    colorPickerPlus.hue,
                    this.value / 100,
                    colorPickerPlus.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.valueTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    colorPickerPlus.hue,
                    colorPickerPlus.saturation,
                    this.value / 100);
                colorPickerPlus.notifySelectObservers();
            }
        
            
            /**
             * Register for updates from these pickers
             */
            if (!this.saturationValuePicker.originalDragObservers){
                this.saturationValuePicker.originalDragObservers = [];
            }
            this.saturationValuePicker.originalDragObservers.push(this);
            
            if (!this.saturationValuePicker.originalSelectObservers){
                this.saturationValuePicker.originalSelectObservers = [];
            }
            this.saturationValuePicker.originalSelectObservers.push(this);
        
        
            if (!this.huePicker.originalDragObservers){
                this.huePicker.originalDragObservers = [];
            }
            this.huePicker.originalDragObservers.push(this);
            
            if (!this.huePicker.originalSelectObservers){
                this.huePicker.originalSelectObservers = [];
            }
            this.huePicker.originalSelectObservers.push(this);
            
            this.hue = 0;
            this.saturation = 0;
            this.value = 0;
        
        ]]></constructor>
        
        <!--Get the current Hue-->
        <method name="getHue">
            <body><![CDATA[
                return this.hue;
            ]]></body>
        </method>
        
        <!--Get the current Saturation-->
        <method name="getSaturation">
            <body><![CDATA[
                return this.saturation;
            ]]></body>
        </method>
        
        <!--Get the current Value-->
        <method name="getValue">
            <body><![CDATA[
                return this.value;
            ]]></body>
        </method>
        
        <method name="getRGB">
            <body><![CDATA[
                return this.rgb;
            ]]></body>
        </method>
        
        <!--Set the Hue, Saturation and Value for
            this picker directly.
            
            hue is a number from 0 to 360.
            saturation is a number from 0 to 1
            value is a number from 0 to 1
            -->
        <method name="setHSV">
            <parameter name="hue" />
            <parameter name="saturation" />
            <parameter name="value" />
            <body><![CDATA[
                this.huePicker.setHue(hue);
                this.saturationValuePicker.setHue(hue);
                this.saturationValuePicker.setSaturation(saturation);
                this.saturationValuePicker.setValue(value);
                
                this.hue = hue;
                this.saturation = saturation;
                this.value = value;
                
                this.rgb = this.HSVtoRGB(
                                this.hue,
                                this.saturation,
                                this.value);
                
                this.updateTextInputs();
                //this.notifyDragObservers();
            ]]></body>
        </method>
        
        <!--Set the Red, Green and Blue channels for
            this picker directly.
            
            Each channel is a number in the range 0-255
            -->
        <method name="setRGB">
            <parameter name="red" />
            <parameter name="green" />
            <parameter name="blue" />
            <body><![CDATA[
                this.rgb = [red,green,blue];
                var hsv = this.RGBtoHSV(red, green, blue);
                this.hue = hsv[0];
                this.saturation = hsv[1];
                this.value = hsv[2];
                
                this.huePicker.setHue(this.hue);
                this.saturationValuePicker.setHue(this.hue);
                this.saturationValuePicker.setSaturation(this.saturation);
                this.saturationValuePicker.setValue(this.value);
                
                this.updateTextInputs();
            ]]></body>
        </method>
        
        <method name="updatePickerSelect">
            <parameter name="picker" />
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
        
        <method name="updatePickerDrag">
            <parameter name="picker" />
            <body><![CDATA[
                if(picker == this.huePicker){
                    this.hue = picker.getHue();
                    this.saturationValuePicker.setHue(this.hue);
                }
                else if(picker == this.saturationValuePicker){
                    this.saturation = picker.getSaturation();
                    this.value = picker.getValue();
                }
                this.rgb = this.HSVtoRGB(
                                this.hue,
                                this.saturation,
                                this.value);
                this.updateTextInputs();
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <method name="updateTextInputs">
            <body><![CDATA[
                this.redTextbox.value = this.rgb[0];
                this.greenTextbox.value = this.rgb[1];
                this.blueTextbox.value = this.rgb[2];
                this.hueTextbox.value = this.hue;
                this.saturationTextbox.value = this.saturation * 100;
                this.valueTextbox.value = this.value * 100;
            ]]>
            </body>
        </method>
        
        <!--Given Hue, Saturation and Value, return
            an array of RGB integer values in the range
            0 to 255-->
        <method name="HSVtoRGB">
            <parameter name="hue" />
            <parameter name="saturation" />
            <parameter name="value" />
            <body><![CDATA[
                hue /= 60;
                var aChannel, bChannel, offset;
                var sector;
                var hex = "rgb(";
                
                sector = Math.floor(hue);
                
                offset = hue - sector;
                if (sector % 2 == 0){
                    offset = 1 - offset;
                }
                
                aChannel = value * (1 - saturation);
                bChannel = value * (1 - saturation * offset);
                
                value = Math.round(value * 255);
                aChannel = Math.round(aChannel * 255);
                bChannel = Math.round(bChannel * 255);
                
                var rgb = [];
                switch (sector) {
                    case 6:
                    case 0: rgb = [value, bChannel, aChannel];
                        break;
                    case 1: rgb = [bChannel, value, aChannel];
                        break;
                    case 2: rgb = [aChannel, value, bChannel];
                        break;
                    case 3: rgb = [aChannel, bChannel, value];
                        break;
                    case 4: rgb = [bChannel, aChannel, value];
                        break;
                    case 5: rgb = [value, aChannel, bChannel];
                        break;
                }
                return rgb;
            ]]>
            </body>
        </method>
        
        
        <method name="RGBtoHSV">
            <parameter name="red" />
            <parameter name="green" />
            <parameter name="blue" />
            <body><![CDATA[
                //Convert to 0-1 scale
                var r = red / 255;
                var g = green / 255;
                var b = blue / 255;
                
                //Get the minimum and maximum values and the
                //interval between them
                var min = Math.min(r, g, b);
                var max = Math.max(r, g, b);
                var delta = max - min;
                
                var hue, saturation, value;
                
                //Value is always the max value of RGB
                value = max;
                
                if (delta == 0) {
                    //Greyscale
                    hue = 0;
                    saturation = 0;
                } else{
                    saturation = delta / max;
                    
                    //Calculate the hue
                    var rDelta = (((max - r) / 6) + (delta / 2)) / delta;
                    var gDelta = (((max - g) / 6) + (delta / 2)) / delta;
                    var bDelta = (((max - b) / 6) + (delta / 2)) / delta;
                    
                    switch(max){
                        case r:
                            hue = bDelta - gDelta;
                            break;
                        case g:
                            hue = (1 / 3) + rDelta - bDelta;
                            break;
                        case b:
                            hue = (2 / 3) + gDelta - rDelta;
                            break;
                    }
                    
                    //Make sure hue is in the 0 to 1 range
                    if (hue < 0){
                        hue += 1;
                    }
                    if (hue > 1){
                        hue -= 1;
                    }
                }
                
                //Scale back to degrees
                hue *= 360;
                
                return [hue, saturation, value];
            ]]>
            </body>
        </method>
    </implementation>

    <handlers>
    </handlers>
</binding>

</bindings>