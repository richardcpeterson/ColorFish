<?xml version="1.0"?>
<bindings
  xmlns="http://www.mozilla.org/xbl"
  xmlns:xbl="http://www.mozilla.org/xbl"
     xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
>


<!--A picker that can have selected or dragged
    values, and can notify observers of changes to
    these values.
    
    A dragged value is a transient value set while
    the user drags over the picker. A selected value
    is the final value selected by the user, usually
    by releasing the mouse button-->
<binding id="observablePicker">
    <implementation>
        <constructor><![CDATA[
            this.dragObservers = [];
            this.selectObservers = [];
            
            //Register any original observers set before
            //this constructor ran
            if(this.originalDragObservers){
                this.dragObservers = this.originalDragObservers;
            }
            if(this.originalSelectObservers){
                this.selectObservers = this.originalSelectObservers;
            }
        ]]>
        </constructor>
        
        <!--Add an observer that will be notified when
            final selections are made on this picker
            The observer must implement the method
            updatePickerSelect(picker)-->
        <method name="addSelectObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.selectObservers.push(observer);
            ]]>
            </body>
        </method>
        
        <!--Add an observer that will be notified of
            transient values while this picker is being
            dragged.
            The observer must implement the method
            updatePickerDrag(picker)-->
        <method name="addDragObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.dragObservers.push(observer);
            ]]>
            </body>
        </method>
        
        <method name="removeSelectObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.selectObservers.remove(observer);
            ]]>
            </body>
        </method>
        
        <method name="removeDragObserver">
            <parameter name="observer" />
            <body><![CDATA[
                this.dragObservers.remove(observer);
            ]]>
            </body>
        </method>
        
        <!--Notify all select observers of a change
            to this picker's selected value-->
        <method name="notifySelectObservers">
            <body><![CDATA[
                for(var i = 0; i < this.selectObservers.length; i++){
                    this.selectObservers[i].updatePickerSelect(this);
                }
            ]]>
            </body>
        </method>
        
        <!--Notify all drag observers of a change to
            the value being dragged over-->
        <method name="notifyDragObservers">
            <parameter name="observer" />
            <body><![CDATA[
                for(var i = 0; i < this.dragObservers.length; i++){
                    this.dragObservers[i].updatePickerDrag(this);
                }
            ]]>
            </body>
        </method>
    </implementation>
</binding>

<binding id="verticalPicker"
    extends="#observablePicker">
    <resources>
        <stylesheet src="verticalPicker.css"/>
    </resources>

    <content>
        <xul:vbox
            flex="1"
            anonid="container"
            pack="center"
            align="center">
            <xul:box
                anonid="holder">
                <xul:box
                anonid="activeRegion">
                    <xul:box
                        id="slide"
                        anonid="slide"
                        style="TOP: -3px; LEFT: -7px;">
                    </xul:box>
                </xul:box>
            </xul:box>
        </xul:vbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.activeRegion = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "activeRegion"
            );
            
            this.slide = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "slide"
            );
            
            this.bottomBound =
                (this.originalBottomBoundaryValue)?
                 this.originalBottomBoundaryValue :
                 0;
            
            this.topBound =
                (this.originalTopBoundaryValue)?
                 this.originalTopBoundaryValue :
                 100;
            
            this.slideY = 0;
            
            this.updateRange();
        ]]>
        </constructor>
        
        <!--Set the numeric value represented when the
            slide is all the way to the top-->
        <method name="setTopBoundaryValue">
            <parameter name="topBoundaryValue"/>
            <body><![CDATA[
                this.topBound = topBoundaryValue;
                this.updateRange();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            slide is all the way to the bottom-->
        <method name="setBottomBoundaryValue">
            <parameter name="bottomBoundaryValue"/>
            <body><![CDATA[
                this.bottomBound = bottomBoundaryValue;
                this.updateRange();
            ]]></body>
        </method>
        
        <!--Set the minValue and maxValue to reflect
            the current state of bottomBound and topBound.
            The max and min values are used in order to save
            comparisons throughout the rest of the code.-->
        <method name="updateRange">
            <body><![CDATA[
                this.maxValue =
                    Math.max(this.topBound, this.bottomBound);
                this.minValue =
                    Math.min(this.topBound, this.bottomBound);
                    
                this.range = this.bottomBound - this.topBound;
            ]]>
            </body>
        </method>
        
        <!--Get the current value represented
            by the position of the slide-->
        <method name="getValue">
            <body><![CDATA[
                return this.value;
            ]]></body>
        </method>
        
        
        <!--Set the position of the slide to the
            specified value. Value must be numeric.
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setValue">
            <parameter name="value" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                this.value =
                    Math.min(
                        this.maxValue,
                        Math.max(
                            this.minValue,
                            value
                        )
                    );
                    
                this.slideY =
                    ((this.value - this.topBound) / this.range)
                    * this.activeRegion.boxObject.height;
                this.slide.setAttribute(
                    "style",
                    "top: "+(this.slideY-3)+"px; left: -7px;"
                );
            ]]></body>
        </method>
        
        <!--Private use
            Update the value based on the current pixel
            position of the slide-->
        <method name="dragValue">
            <body><![CDATA[
                
                /**
                 * Translate screen coordinates into
                 * logical coordinates
                 */
                
                this.value =
                    ((this.slideY / this.activeRegion.boxObject.height)
                      * this.range
                    )
                    + this.topBound;
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <!--Private use
            Select a final value
            based on the current pixel position of the
            slide. This is for whan an actual selection
            is made - not for transient values while
            dragging around.-->
        <method name="selectValue">
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
        
    </implementation>

    <handlers>
        <handler event="mousedown" button="0" modifiers="none"><![CDATA[
            var element = this;
            function drag(event) {
                var newY = event.pageY - element.activeRegion.boxObject.y;
                newY = Math.max(0, Math.min(newY, element.activeRegion.boxObject.height));
                
                element.slideY = newY;
                
                newY -=3;
                
                element.slide.setAttribute(
                    "style",
                    "top: "+newY+"px; left: -7px;"
                );
                
                element.dragValue();
            }
            
            element.activeRegion.addClass("noCursor");
            
            var originalDocumentOnmousemove = document.onmousemove;
            var originalDocumentOnmouseup = document.onmouseup;
            
            document.onmousemove=drag;
            document.onmouseup=function(){
                element.selectValue();
                element.activeRegion.removeClass("noCursor");
                document.onmousemove=originalDocumentOnmousemove;
                document.onmouseup=originalDocumentOnmouseup;
            };
            drag(event);
            
            event.stopPropagation();
        ]]>
        </handler>
    </handlers>
</binding>


<binding id="huePicker"
    extends="#verticalPicker">
    <resources>
        <stylesheet src="hue.css"/>
    </resources>
    
    <implementation>
        <constructor><![CDATA[
            this.setTopBoundaryValue(360);
            this.setBottomBoundaryValue(0);
        ]]></constructor>
        
        <!--Get the current Hue-->
        <method name="getHue">
            <body><![CDATA[
                return this.value % 360;
            ]]></body>
        </method>
        
        <!--Set the current Hue-->
        <method name="setHue">
            <parameter name="hue" />
            <body><![CDATA[
                this.setValue(hue);
            ]]></body>
        </method>
    </implementation>
</binding>

<binding id="twoDimensionalPicker"
    extends="#observablePicker">
    <resources>
        <stylesheet src="twoDimensionalPicker.css"/>
    </resources>

    <content>
        <xul:vbox
            flex="1"
            anonid="container"
            pack="center"
            align="center">
            <xul:box
                anonid="holder">
            <xul:box
                anonid="activeRegion">
                <xul:box
                    id="picker"
                    anonid="picker"
                    style="TOP: -4px; LEFT: -4px;">
                </xul:box>
            </xul:box></xul:box>
        </xul:vbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            
            this.activeRegion = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "activeRegion"
            );
            
            this.picker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "picker"
            );
            
            this.pickerX = 0;
            this.pickerY = 0;
            
            this.leftBound =
                (this.originalLeftBoundaryValue)?
                 this.originalLeftBoundaryValue :
                 0;
            
            this.rightBound =
                (this.originalRightBoundaryValue)?
                 this.originalRightBoundaryValue :
                 100;
            
            this.bottomBound =
                (this.originalBottomBoundaryValue)?
                 this.originalBottomBoundaryValue :
                 0;
            
            this.topBound =
                (this.originalTopBoundaryValue)?
                 this.originalTopBoundaryValue :
                 100;
            
            this.updateRanges();
        ]]>
        </constructor>
        
        <!--Set the numeric value represented when the
            picker is all the way to the left-->
        <method name="setLeftBoundaryValue">
            <parameter name="leftBoundaryValue"/>
            <body><![CDATA[
                this.leftBound = leftBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            picker is all the way to the right-->
        <method name="setRightBoundaryValue">
            <parameter name="rightBoundaryValue"/>
            <body><![CDATA[
                this.rightBound = rightBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method> 
        
        <!--Set the numeric value represented when the
            picker is all the way to the top-->
        <method name="setTopBoundaryValue">
            <parameter name="topBoundaryValue"/>
            <body><![CDATA[
                this.topBound = topBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the numeric value represented when the
            picker is all the way to the bottom-->
        <method name="setBottomBoundaryValue">
            <parameter name="bottomBoundaryValue"/>
            <body><![CDATA[
                this.bottomBound = bottomBoundaryValue;
                this.updateRanges();
            ]]></body>
        </method>
        
        <!--Set the horizontalMinValue, horizontalMaxValue,
            verticalMinValue and verticalMaxValue to reflect
            the current state of leftBound, rightBound,
            bottomBound, topBound.
            The max and min values are used in order to save
            comparisons throughout the rest of the code.-->
        <method name="updateRanges">
            <body><![CDATA[
                this.horizontalMaxValue =
                    Math.max(this.leftBound, this.rightBound);
                this.horizontalMinValue =
                    Math.min(this.leftBound, this.rightBound);
                this.verticalMaxValue =
                    Math.max(this.topBound, this.bottomBound);
                this.verticalMinValue =
                    Math.min(this.topBound, this.bottomBound);
                    
                this.verticalRange = this.bottomBound - this.topBound;
                this.horizontalRange = this.rightBound - this.leftBound;
            ]]>
            </body>
        </method>
        
        <!--Get the current horizontal value represented
            by the position of the picker-->
        <method name="getHorizontalValue">
            <body><![CDATA[
                return this.horizontalValue;
            ]]></body>
        </method>
        
        <!--Get the current vertical value represented
            by the position of the picker-->
        <method name="getVerticalValue">
            <body><![CDATA[
                return this.verticalValue;
            ]]></body>
        </method>
        
        
        <!--Set the position of the picker to the
            specified value. Value must be numeric
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setHorizontalValue">
            <parameter name="horizontalValue" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting x
                this.horizontalValue =
                    Math.min(
                        this.horizontalMaxValue,
                        Math.max(
                            this.horizontalMinValue,
                            horizontalValue
                        )
                    );
                this.pickerX =
                    ((this.horizontalValue - this.leftBound) / this.horizontalRange)
                    * this.activeRegion.boxObject.width;  
                this.picker.setAttribute(
                    "style",
                    "top: "+(this.pickerY-4)+"px; left: "+(this.pickerX-4)+"px;"
                );
            ]]></body>
        </method>
        
        <!--Set the position of the picker to the
            specified value. Value must be numeric.
            Out of bounds values will be clipped to
            their closest legal value.-->
        <method name="setVerticalValue">
            <parameter name="verticalValue" />
            <body><![CDATA[
                //Clip the value to a legal value
                //before setting y
                this.verticalValue =
                    Math.min(
                        this.verticalMaxValue,
                        Math.max(
                            this.verticalMinValue,
                            verticalValue
                        )
                    );
                this.pickerY =
                    ((this.verticalValue - this.topBound) / this.verticalRange)
                    * this.activeRegion.boxObject.height;
                this.picker.setAttribute(
                    "style",
                    "top: "+(this.pickerY-4)+"px; left: "+(this.pickerX-4)+"px;"
                );
            ]]></body>
        </method>
        
        <!--Private use
            Update the vertical and horizontal values
            based on the current XY pixel position of
            the picker-->
        <method name="dragValues">
            <body><![CDATA[
                
                /**
                 * Translate screen coordinates into
                 * logical coordinates
                 */
                
                this.horizontalValue =
                    ((this.pickerX / this.activeRegion.boxObject.width)
                      * this.horizontalRange
                    )
                    + this.leftBound;
                
                this.verticalValue =
                    ((this.pickerY / this.activeRegion.boxObject.height)
                      * this.verticalRange
                    )
                    + this.topBound;
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <!--Private use
            Register a final change to the the vertical and
            horizontal values based on the current XY pixel
            position of the picker. This is for whan an
            actual selection is made - not for transient
            values while dragging around.-->
        <method name="selectValues">
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
            
        
        
    </implementation>

    <handlers>
        <handler event="mousedown" button="0" modifiers="none"><![CDATA[
            var element = this;
            function drag(event) {
                var newX = event.pageX - element.activeRegion.boxObject.x;
                var newY = event.pageY - element.activeRegion.boxObject.y;
                newY = Math.max(0, Math.min(newY, element.activeRegion.boxObject.height));
                newX = Math.max(0, Math.min(newX, element.activeRegion.boxObject.width));
                
                element.pickerX = newX;
                element.pickerY = newY;
                
                newX -=4;
                newY -=4;
                
                element.picker.setAttribute(
                    "style",
                    "top: "+newY+"px; left: " + newX + "px;"
                );
                
                element.dragValues();
            }
            
            element.activeRegion.addClass("noCursor");
            
            var originalDocumentOnmousemove = document.onmousemove;
            var originalDocumentOnmouseup = document.onmouseup;
            
            document.onmousemove=drag;
            document.onmouseup=function(){
                element.selectValues();
                element.activeRegion.removeClass("noCursor");
                document.onmousemove=originalDocumentOnmousemove;
                document.onmouseup=originalDocumentOnmouseup;
            };
            drag(event);
            
            event.stopPropagation();
        ]]>
        </handler>
    </handlers>
</binding>

<binding id="saturationValuePicker"
    extends="#twoDimensionalPicker">
    <resources>
        <stylesheet src="saturationValue.css"/>
    </resources>

    <implementation>
        <constructor><![CDATA[
            this.setLeftBoundaryValue(0);
            this.setRightBoundaryValue(1);
            this.setTopBoundaryValue(1);
            this.setBottomBoundaryValue(0);
        ]]></constructor>
        
        <!--Get the current Saturation-->
        <method name="getSaturation">
            <body><![CDATA[
                return this.horizontalValue;
            ]]></body>
        </method>
        
        <!--Get the current Value-->
        <method name="getValue">
            <body><![CDATA[
                return this.verticalValue;
            ]]></body>
        </method>
        
        <!--Set the current Saturation-->
        <method name="setSaturation">
            <parameter name="saturation" />
            <body><![CDATA[
                this.setHorizontalValue(saturation);
            ]]></body>
        </method>
        
        <!--Set the current Value-->
        <method name="setValue">
            <parameter name="value" />
            <body><![CDATA[
                this.setVerticalValue(value);
            ]]></body>
        </method>
        
        <!--Set the background hue of this picker-->
        <method name="setHue">
            <parameter name="hue" />
            <body><![CDATA[
                /**
                 * This sets the hue of the background
                 * element for this color picker. It
                 * does not do full HSB to RGB conversion,
                 * since the saturation and value will
                 * always be full.
                 *
                 * This algorithm works by breaking the
                 * spectrum into six sectors.
                 * Sectors 1 and 2 are the G sectors.
                 * Sectors 3 and 4 are the B sectors.
                 * Sectors 5 and 6 are teh R sectors.
                 *
                 * When the hue is in a particular sector,
                 * that sector's channel is at full strength.
                 * Depending on the sector, a secondary
                 * channel will be at partial strength.
                 * The secondary channel is the "bChannel"
                 * here.
                 */
            
                var bChannel, sector;
                var hex = "rgb(";
                
                //Break the hue into six sectors
                hue /= 60;
                sector = Math.floor(hue);
                
                //Calculate a secondary channel strength
                //based on how far into the sector the
                //particular hue is found
                bChannel = hue - sector;
                if (sector % 2 != 0){
                    bChannel = 1 - bChannel;
                }
                
                //convert to 0-255 scale
                bChannel = Math.round(bChannel * 255);
                
                var rgb = [];
                switch (sector) {
                    case 6:
                    case 0: rgb = [255, bChannel, 0];
                        break;
                    case 1: rgb = [bChannel, 255, 0];
                        break;
                    case 2: rgb = [0, 255, bChannel];
                        break;
                    case 3: rgb = [0, bChannel, 255];
                        break;
                    case 4: rgb = [bChannel, 0, 255];
                        break;
                    case 5: rgb = [255, 0, bChannel];
                        break;
                }
                
                //Make the final CSS "rgb(0,0,0)" string
                hex += rgb.join(",") + ")";
                
                //Set the background color
                this.activeRegion.setAttribute(
                    "style",
                    "background-color: " + hex
                );
            ]]>
            </body>
        </method>
    </implementation>

    <handlers>
    </handlers>
</binding>

<binding id="eyedropper"
    extends="#observablePicker">
    <content>
        <xul:label>Eyedropper</xul:label>
    </content>
    <implementation>
        <!--Private use-->
        <method name="selectValue">
            <body><![CDATA[
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
    </implementation>
    <handlers>
        <handler event="click" button="0" modifiers="none"><![CDATA[
            var element = this;
            
            function drag(event) {
                
                //Get the parent window
                var window = event.target.ownerDocument.defaultView;
            
                //Find the actual cursor position
                var pageX = event.clientX + window.scrollX;
                var pageY = event.clientY + window.scrollY;
            
                //Make a 1px canvas document upon which to draw the pixel from
                //the underlying window
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = 1;
                canvas.height = 1;
                var context = canvas.getContext("2d");
            
                //draws the contents of the DOM at pageX, pageY into the 1px canvas
                //on a white background
                //(See MDC documentation for canvas.drawWindow())
                context.drawWindow(window, pageX, pageY, 1, 1, "white");
            
                //Get the data from the canvas
                var data = context.getImageData(0, 0, 1, 1).data;
                
                element.rgb = data;
                element.notifyDragObservers();
            }
            
            /* TODO:
                what goes here? We want to be able to set an
               eyedropper cursor for the whole app.
            
            
            //This doesn't work because it only sets the crosshairs for
            //window XUL elements, NOT the website we're browsing.
            window.document.documentElement.setAttribute(
                "style",
                "cursor: crosshair"
            );
            */
            
            
            var originalDocumentOnmousemove = document.onmousemove;
            var originalDocumentOnclick = document.onclick;
            
            document.onmousemove=drag;
            document.onclick=function(){
                element.selectValue();
                window.document.documentElement.setAttribute("style","");
                
                /* TODO: Undo setting the eyedropper cursor here */
                
                document.onmousemove=originalDocumentOnmousemove;
                document.onclick=originalDocumentOnclick;
            };
            drag(event);
            
            event.stopPropagation();
        ]]>
        </handler>
    </handlers>
</binding>

<binding id="colorPickerPlus"
    extends="#observablePicker">
    <resources>
        <stylesheet src="colorPickerPlus.css"/>
    </resources>
    
    <content>
        <xul:hbox
            align="left"
            anonid="container">
            <xul:saturationValuePicker
                anonid="saturationValuePicker"/>
            <xul:huePicker
                anonid="huePicker"/>
            <xul:spacer anonid="beforeText" flex="1" />
            <xul:vbox pack="start">
                <xul:hbox>
                    <xul:box anonid="colorPreview">
                    </xul:box>
                    <xul:eyedropper anonid="eyedropper">
                    </xul:eyedropper>
                </xul:hbox>
                <xul:hbox
                    anonid="textInputs">
                    <xul:vbox
                        anonid="rgbInputs">
                        <xul:hbox
                            anonid="redInput">
                            <xul:label
                                value="R" control="redTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="redTextbox"
                                anonid="redTextbox"
                                class="colorTextInput"
                                type="number" min="0" max="255"/>
                        </xul:hbox>
                        <xul:hbox
                            anonid="greenInput">
                            <xul:label
                                value="G" control="greenTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="greenTextbox"
                                anonid="greenTextbox"
                                class="colorTextInput"
                                type="number" min="0" max="255"/>
                        </xul:hbox>
                        <xul:hbox
                            anonid="blueInput">
                            <xul:label
                                value="B" control="blueTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="blueTextbox"
                                anonid="blueTextbox"
                                class="colorTextInput"
                                type="number" min="0" max="255"/>
                        </xul:hbox>
                    </xul:vbox>
                    <xul:spacer flex="1" />
                    <xul:vbox
                        anonid="hsvInputs">
                        <xul:hbox
                            anonid="hueInput">
                            <xul:label
                                value="H" control="hueTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="hueTextbox"
                                anonid="hueTextbox"
                                class="colorTextInput"
                                wraparound="true"
                                type="number" min="0" max="360"/>
                        </xul:hbox>
                        <xul:hbox
                            anonid="saturationInput">
                            <xul:label
                                value="S" control="saturationTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="saturationTextbox"
                                anonid="saturationTextbox"
                                class="colorTextInput"
                                type="number" min="0" max="100"/>
                        </xul:hbox>
                        <xul:hbox
                            anonid="valueInput">
                            <xul:label
                                value="V" control="valueTextbox"/>
                            <xul:spacer flex="1"/>
                            <xul:textbox
                                id="valueTextbox"
                                anonid="valueTextbox"
                                class="colorTextInput"
                                type="number" min="0" max="100"/>
                        </xul:hbox>
                    </xul:vbox>
                </xul:hbox>
            </xul:vbox>
        </xul:hbox>
    </content>

    <implementation>
        <constructor><![CDATA[
            this.saturationValuePicker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "saturationValuePicker"
            );
            
            this.huePicker = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "huePicker"
            );
            
            
            this.redTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "redTextbox"
            );
            this.greenTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "greenTextbox"
            );
            this.blueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "blueTextbox"
            );
            
            this.hueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "hueTextbox"
            );
            this.saturationTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "saturationTextbox"
            );
            this.valueTextbox = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "valueTextbox"
            );
            this.colorPreview = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "colorPreview"
            );
            this.eyedropper = document.getAnonymousElementByAttribute(
                    this,
                    "anonid",
                    "eyedropper"
            );
            
            
            var colorPickerPlus = this;
            
            this.redTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    this.value,
                    colorPickerPlus.rgb[1],
                    colorPickerPlus.rgb[2]);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.greenTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    colorPickerPlus.rgb[0],
                    this.value,
                    colorPickerPlus.rgb[2]);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.blueTextbox.onchange = function(){
                colorPickerPlus.setRGB(
                    colorPickerPlus.rgb[0],
                    colorPickerPlus.rgb[1],
                    this.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.hueTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    this.value,
                    colorPickerPlus.saturation,
                    colorPickerPlus.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.saturationTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    colorPickerPlus.hue,
                    this.value / 100,
                    colorPickerPlus.value);
                colorPickerPlus.notifySelectObservers();
            }
            
            this.valueTextbox.onchange = function(){
                colorPickerPlus.setHSV(
                    colorPickerPlus.hue,
                    colorPickerPlus.saturation,
                    this.value / 100);
                colorPickerPlus.notifySelectObservers();
            }
        
            
            /**
             * Register for updates from these pickers
             */
            if (!this.saturationValuePicker.originalDragObservers){
                this.saturationValuePicker.originalDragObservers = [];
            }
            this.saturationValuePicker.originalDragObservers.push(this);
            
            if (!this.saturationValuePicker.originalSelectObservers){
                this.saturationValuePicker.originalSelectObservers = [];
            }
            this.saturationValuePicker.originalSelectObservers.push(this);
        
        
            if (!this.huePicker.originalDragObservers){
                this.huePicker.originalDragObservers = [];
            }
            this.huePicker.originalDragObservers.push(this);
            
            if (!this.huePicker.originalSelectObservers){
                this.huePicker.originalSelectObservers = [];
            }
            this.huePicker.originalSelectObservers.push(this);
            
            if (!this.eyedropper.originalDragObservers){
                this.eyedropper.originalDragObservers = [];
            }
            this.eyedropper.originalDragObservers.push(this);
            
            if (!this.eyedropper.originalSelectObservers){
                this.eyedropper.originalSelectObservers = [];
            }
            this.eyedropper.originalSelectObservers.push(this);
            
            
            this.hue = 0;
            this.saturation = 0;
            this.value = 0;
        
        ]]></constructor>
        
        <!--Get the current Hue-->
        <method name="getHue">
            <body><![CDATA[
                return this.hue;
            ]]></body>
        </method>
        
        <!--Get the current Saturation-->
        <method name="getSaturation">
            <body><![CDATA[
                return this.saturation;
            ]]></body>
        </method>
        
        <!--Get the current Value-->
        <method name="getValue">
            <body><![CDATA[
                return this.value;
            ]]></body>
        </method>
        
        <method name="getRGB">
            <body><![CDATA[
                return this.rgb;
            ]]></body>
        </method>
        
        <!--Set the Hue, Saturation and Value for
            this picker directly.
            
            hue is a number from 0 to 360.
            saturation is a number from 0 to 1
            value is a number from 0 to 1
            -->
        <method name="setHSV">
            <parameter name="hue" />
            <parameter name="saturation" />
            <parameter name="value" />
            <body><![CDATA[
                this.huePicker.setHue(hue);
                this.saturationValuePicker.setHue(hue);
                this.saturationValuePicker.setSaturation(saturation);
                this.saturationValuePicker.setValue(value);
                
                this.hue = hue;
                this.saturation = saturation;
                this.value = value;
                
                this.rgb = this.HSVtoRGB(
                                this.hue,
                                this.saturation,
                                this.value);
                
                this.updateTextInputs();
                this.updateColorPreview(this.rgb[0],this.rgb[1],this.rgb[2]);
                //this.notifyDragObservers();
            ]]></body>
        </method>
        
        <!--Set the Red, Green and Blue channels for
            this picker directly.
            
            Each channel is a number in the range 0-255
            -->
        <method name="setRGB">
            <parameter name="red" />
            <parameter name="green" />
            <parameter name="blue" />
            <body><![CDATA[
                this.rgb = [red,green,blue];
                var hsv = this.RGBtoHSV(red, green, blue);
                this.hue = hsv[0];
                this.saturation = hsv[1];
                this.value = hsv[2];
                
                this.huePicker.setHue(this.hue);
                this.saturationValuePicker.setHue(this.hue);
                this.saturationValuePicker.setSaturation(this.saturation);
                this.saturationValuePicker.setValue(this.value);
                
                this.updateTextInputs();
                this.updateColorPreview(this.rgb[0],this.rgb[1],this.rgb[2]);
            ]]></body>
        </method>
        
        <method name="updatePickerSelect">
            <parameter name="picker" />
            <body><![CDATA[
                if(picker == this.eyedropper){
                    this.setRGB(picker.rgb[0],picker.rgb[1],picker.rgb[2]);
                }
                this.notifySelectObservers();
            ]]>
            </body>
        </method>
        
        <method name="updatePickerDrag">
            <parameter name="picker" />
            <body><![CDATA[
                if(picker == this.eyedropper){
                    this.updateColorPreview(
                        picker.rgb[0],
                        picker.rgb[1],
                        picker.rgb[2]
                    );
                    return;
                }
                
                if(picker == this.huePicker){
                    this.hue = picker.getHue();
                    this.saturationValuePicker.setHue(this.hue);
                }
                else if(picker == this.saturationValuePicker){
                    this.saturation = picker.getSaturation();
                    this.value = picker.getValue();
                }
                this.rgb = this.HSVtoRGB(
                                this.hue,
                                this.saturation,
                                this.value);
                this.updateTextInputs();
                this.updateColorPreview(this.rgb[0],this.rgb[1],this.rgb[2]);
                this.notifyDragObservers();
            ]]>
            </body>
        </method>
        
        <method name="updateTextInputs">
            <body><![CDATA[
                this.redTextbox.value = this.rgb[0];
                this.greenTextbox.value = this.rgb[1];
                this.blueTextbox.value = this.rgb[2];
                this.hueTextbox.value = this.hue;
                this.saturationTextbox.value = this.saturation * 100;
                this.valueTextbox.value = this.value * 100;
            ]]>
            </body>
        </method>
        
        <!--Update the color preview swatch with the given RGB values-->
        <method name="updateColorPreview">
            <parameter name="red" />
            <parameter name="green" />
            <parameter name="blue" />
            <body><![CDATA[
                this.colorPreview.setAttribute(
                    "style",
                    "background-color: rgb(" +
                        red + ", " + 
                        green + ", " + 
                        blue + ")" 
                    );
            ]]>
            </body>
        </method>
        
        <!--Given Hue, Saturation and Value, return
            an array of RGB integer values in the range
            0 to 255-->
        <method name="HSVtoRGB">
            <parameter name="hue" />
            <parameter name="saturation" />
            <parameter name="value" />
            <body><![CDATA[
                hue /= 60;
                var aChannel, bChannel, offset;
                var sector;
                var hex = "rgb(";
                
                sector = Math.floor(hue);
                
                offset = hue - sector;
                if (sector % 2 == 0){
                    offset = 1 - offset;
                }
                
                aChannel = value * (1 - saturation);
                bChannel = value * (1 - saturation * offset);
                
                value = Math.round(value * 255);
                aChannel = Math.round(aChannel * 255);
                bChannel = Math.round(bChannel * 255);
                
                var rgb = [];
                switch (sector) {
                    case 6:
                    case 0: rgb = [value, bChannel, aChannel];
                        break;
                    case 1: rgb = [bChannel, value, aChannel];
                        break;
                    case 2: rgb = [aChannel, value, bChannel];
                        break;
                    case 3: rgb = [aChannel, bChannel, value];
                        break;
                    case 4: rgb = [bChannel, aChannel, value];
                        break;
                    case 5: rgb = [value, aChannel, bChannel];
                        break;
                }
                return rgb;
            ]]>
            </body>
        </method>
        
        
        <method name="RGBtoHSV">
            <parameter name="red" />
            <parameter name="green" />
            <parameter name="blue" />
            <body><![CDATA[
                //Convert to 0-1 scale
                var r = red / 255;
                var g = green / 255;
                var b = blue / 255;
                
                //Get the minimum and maximum values and the
                //interval between them
                var min = Math.min(r, g, b);
                var max = Math.max(r, g, b);
                var delta = max - min;
                
                var hue, saturation, value;
                
                //Value is always the max value of RGB
                value = max;
                
                if (delta == 0) {
                    //Greyscale
                    hue = 0;
                    saturation = 0;
                } else{
                    saturation = delta / max;
                    
                    //Calculate the hue
                    var rDelta = (((max - r) / 6) + (delta / 2)) / delta;
                    var gDelta = (((max - g) / 6) + (delta / 2)) / delta;
                    var bDelta = (((max - b) / 6) + (delta / 2)) / delta;
                    
                    switch(max){
                        case r:
                            hue = bDelta - gDelta;
                            break;
                        case g:
                            hue = (1 / 3) + rDelta - bDelta;
                            break;
                        case b:
                            hue = (2 / 3) + gDelta - rDelta;
                            break;
                    }
                    
                    //Make sure hue is in the 0 to 1 range
                    if (hue < 0){
                        hue += 1;
                    }
                    if (hue > 1){
                        hue -= 1;
                    }
                }
                
                //Scale back to degrees
                hue *= 360;
                
                return [hue, saturation, value];
            ]]>
            </body>
        </method>
    </implementation>

    <handlers>
    </handlers>
</binding>

</bindings>